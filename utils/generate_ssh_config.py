import os
import re
from pathlib import Path

import boto3

IDENTIFIER = os.environ.get("IDENTIFIER", "dev")
SSH_CONFIG_ENTRY_REGEX = (
    r"# Generated by the remote-workstation project\n"
    rf"Host remote-workstation-{IDENTIFIER}\n.*\n.*\n.*"
)


def get_instance_ip() -> str:
    """
    For a given identifier for a deployment (env var of IDENTIFIER), find the cluster
    that was deployed, find the tasks within the cluster (there should only be one),
    find the network interfaces on that task, and return the public IP of the instance
    :returns: str The public ip of the remote instance
    """
    ecs_c = boto3.client("ecs")
    task_arns = ecs_c.list_tasks(
        cluster=f"remote-cluster-{IDENTIFIER}", desiredStatus="RUNNING"
    )["taskArns"]
    if task_arns:
        tasks = ecs_c.describe_tasks(
            cluster=f"remote-cluster-{IDENTIFIER}", tasks=task_arns
        )["tasks"]
        # Should only ever be one task and network interface on deployment
        task_details = {
            d["name"]: d["value"] for d in tasks[0]["attachments"][0]["details"]
        }
        interface_id = task_details["networkInterfaceId"]
        ec2_c = boto3.client("ec2")
        network_interfaces = ec2_c.describe_network_interfaces(
            NetworkInterfaceIds=[interface_id]
        )["NetworkInterfaces"]
        return network_interfaces[0]["Association"]["PublicIp"]
    else:
        return None


def generate_ssh_config_entry(instance_ip: str) -> str:
    """
    Given an instance IP address, generate a SSH config entry
    :param instance_ip: str representing the IP address of the instance
    :returns: str The generated SSH config entry
    """
    return f"""# Generated by the remote-workstation project
Host remote-workstation-{IDENTIFIER}
  HostName {instance_ip}
  User root
  IdentityFile {os.environ["SSH_PRIVATE_KEY_LOCATION"]}"""


def find_previous_config_entry_and_replace_or_write_entry_if_not_present(
    ssh_config_entry: str, config_location: str, config_location_dir: str
):
    """
    Given an SSH config entry and the location of the SSH config, check to see if
    the current deployment has an entry, if it does overwrite it, else add it. If
    the SSH config does not exist at the provided location, create it first then
    write to it
    :param ssh_config_entry: str Representing the SSH config entry
    :param config_location: str Representing the full path to the SSH config
    :param config_location_dir: str Representing the directory path where the SSH config
    is
    """
    if not os.path.exists(config_location):
        Path(config_location_dir).mkdir(parents=True, exist_ok=True)
        with open(config_location, "w"):
            pass
        file_content = ""
    else:
        with open(config_location, "r+") as config_file:
            file_content = config_file.read()
    if re.findall(SSH_CONFIG_ENTRY_REGEX, file_content, re.MULTILINE):
        with open(config_location, "r+") as config_file:
            file_content = re.sub(
                SSH_CONFIG_ENTRY_REGEX, ssh_config_entry, file_content
            )
            config_file.seek(0)
            config_file.write(file_content)
            config_file.truncate()
    else:
        with open(config_location, "a") as config_file:
            config_file.write(f"{ssh_config_entry}")
    print(f"SSH config entry has been written to: {config_location}")


def write_config_entry(ssh_config_entry: str, ssh_config_location: str = None):
    """
    Orchestrates find_previous_config_entry_and_replace_or_write_entry_if_not_present,
    if a config location is not provided, the location is hard coded to ./.ssh/config
    :param ssh_config_entry: str Representing the SSH config entry
     :param ssh_config_location: str Representing the full path to the SSH config
    """
    if config_location := ssh_config_location:
        config_location_dir = os.path.dirname(config_location)
        find_previous_config_entry_and_replace_or_write_entry_if_not_present(
            ssh_config_entry, config_location, config_location_dir
        )
    else:
        config_location = "./.ssh/config"
        config_location_dir = "./.ssh"
        find_previous_config_entry_and_replace_or_write_entry_if_not_present(
            ssh_config_entry, config_location, config_location_dir
        )


if __name__ == "__main__":
    """
    Orchestrates the retrieval of the remote workstations IP and writing an
    SSH config entry for it
    """
    if instance_ip := get_instance_ip():
        ssh_config_entry = generate_ssh_config_entry(instance_ip)
        if ssh_config_location := os.environ.get("SSH_CONFIG_LOCATION"):
            write_config_entry(ssh_config_entry, ssh_config_location)
        else:
            write_config_entry(ssh_config_entry)
    else:
        print("No instance found, no SSH config entry to be made")
